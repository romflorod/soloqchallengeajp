<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LoL Wordle - SoloQ Challenge</title>
  <link rel="icon" href="img/logo.jpeg" type="image/jpeg">
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #020617;
      --card-bg: rgba(15, 23, 42, 0.8);
      --correct: #4ade80;
      --present: #fbbf24;
      --absent: #334155;
      --text-main: #f4f4f5;
    }
    body {
      font-family: 'Outfit', sans-serif;
      background-color: var(--bg-dark);
      color: var(--text-main);
      /* Fondo de Aurelion Sol con viñeta radial */
      background: radial-gradient(circle at center, rgba(2, 6, 23, 0.6) 0%, rgba(2, 6, 23, 0.98) 100%), url('https://ddragon.leagueoflegends.com/cdn/img/champion/splash/AurelionSol_0.jpg') no-repeat center center fixed;
      background-size: cover;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    
    /* Texture Overlay */
    body::after {
      content: "";
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
      pointer-events: none;
      z-index: -1;
    }

    h1 { text-transform: uppercase; margin-bottom: 1rem; text-shadow: 0 0 20px rgba(56, 189, 248, 0.5); }
    
    .game-container {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-bottom: 20px;
    }
    
    .row { display: flex; gap: 3px; justify-content: center; }
    
    .tile {
      /* Ajuste para que quepan nombres largos como Fiddlesticks */
      width: clamp(20px, 7vw, 50px);
      height: clamp(20px, 7vw, 50px);
      border: 2px solid rgba(255,255,255,0.1);
      display: flex; align-items: center; justify-content: center;
      font-size: clamp(0.8rem, 3.5vw, 1.5rem); font-weight: 800; text-transform: uppercase;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(4px);
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }
    .tile.filled { border-color: #94a3b8; animation: pop 0.1s; }
    .tile.correct { background-color: var(--correct); border-color: var(--correct); color: #020617; }
    .tile.present { background-color: var(--present); border-color: var(--present); color: #020617; }
    .tile.absent { background-color: var(--absent); border-color: var(--absent); }
    
    .tile.flip {
        animation: flip 0.6s ease forwards;
    }

    @keyframes pop { 50% { transform: scale(1.1); } }
    @keyframes flip {
        0% { transform: rotateX(0); }
        50% { transform: rotateX(90deg); }
        100% { transform: rotateX(0); }
    }
    
    .shake {
        animation: shake 0.5s;
    }
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
        20%, 40%, 60%, 80% { transform: translateX(5px); }
    }

    .keyboard { display: flex; flex-direction: column; gap: 5px; margin-top: 20px; width: 100%; max-width: 500px; padding: 0 5px; }
    .key-row { display: flex; gap: 3px; justify-content: center; width: 100%; }
    .key {
      flex: 1; /* Ocupar espacio disponible */
      height: 50px; display: flex; align-items: center; justify-content: center;
      background: #334155; border-radius: 4px;
      font-weight: 600; cursor: pointer; text-transform: uppercase;
      user-select: none; font-size: 0.9rem;
    }
    .key:hover { background: #475569; }
    .key.correct { background: var(--correct); color: #020617; }
    .key.present { background: var(--present); color: #020617; }
    .key.absent { background: #1e293b; opacity: 0.5; }

    .controls { margin-bottom: 20px; display: flex; gap: 10px; }
    .btn {
      padding: 10px 20px; border-radius: 8px; border: none; font-weight: 700; cursor: pointer;
      background: #38bdf8; color: #020617; text-decoration: none;
    }
    .btn:hover { background: #7dd3fc; }
    .btn-secondary { background: rgba(255,255,255,0.1); color: white; }

    #message { height: 30px; font-weight: bold; color: #fbbf24; margin-bottom: 10px; }
    
    .site-logo {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      object-fit: cover;
      border: 3px solid rgba(56, 189, 248, 0.5);
      box-shadow: 0 0 25px rgba(56, 189, 248, 0.3);
      margin-bottom: 10px;
    }

    @media (max-width: 600px) {
        .site-logo { width: 60px; height: 60px; }
        h1 { font-size: 1.5rem; }
        .key { height: 45px; font-size: clamp(0.6rem, 2.5vw, 0.8rem); }
    }
    
    /* Modal Styles */
    .modal-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex; justify-content: center; align-items: center;
        z-index: 100;
        opacity: 0; pointer-events: none; transition: opacity 0.3s;
        backdrop-filter: blur(5px);
    }
    .modal-overlay.show { opacity: 1; pointer-events: auto; }
    .modal {
        background: #0f172a; border: 1px solid #334155;
        padding: 20px; border-radius: 15px; text-align: center;
        max-width: 90%; width: 400px;
        box-shadow: 0 0 50px rgba(0,0,0,0.5);
        transform: translateY(20px); transition: transform 0.3s;
    }
    .modal-overlay.show .modal { transform: translateY(0); }
    .modal h2 { margin-top: 0; color: #f4f4f5; }
    .modal-img { width: 100%; border-radius: 10px; margin: 15px 0; border: 2px solid #334155; }
    .modal-btn {
        background: #38bdf8; color: #020617; border: none; padding: 10px 20px;
        border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1rem;
        margin-top: 10px;
    }
    .modal-btn:hover { background: #7dd3fc; }
  </style>
</head>
<body>

<img src="img/logo.jpeg" alt="Logo" class="site-logo">
<h1>LoL Wordle</h1>

<div class="controls">
    <a href="/" class="btn btn-secondary">← Volver</a>
    <button onclick="initGame()" class="btn">Nuevo Juego</button>
</div>

<div id="message"></div>

<!-- Modal -->
<div id="modal-overlay" class="modal-overlay">
    <div class="modal">
        <h2 id="modal-title"></h2>
        <div id="modal-content"></div>
        <button class="modal-btn" onclick="initGame()">Jugar de nuevo</button>
    </div>
</div>

<div id="board" class="game-container"></div>
<div id="keyboard" class="keyboard"></div>

<script>
    let champions = [];
    let targetName = "";
    let cleanTarget = "";
    let currentGuess = [];
    let guesses = [];
    let maxGuesses = 6;
    let gameOver = false;

    const API_BASE = window.location.hostname === 'localhost' ? "http://127.0.0.1:5000/api/champions" : "/api/champions";

    async function loadChampions() {
        try {
            const res = await fetch(API_BASE);
            champions = await res.json();
            initGame();
        } catch (e) {
            document.getElementById('message').innerText = "Error cargando campeones.";
        }
    }

    function cleanStr(str) {
        return str.replace(/[^a-zA-Z]/g, '').toUpperCase();
    }

    function initGame() {
        if(champions.length === 0) return;
        
        // Pick random champion
        targetName = champions[Math.floor(Math.random() * champions.length)];
        cleanTarget = cleanStr(targetName);
        
        // Reset state
        currentGuess = [];
        guesses = [];
        gameOver = false;
        document.getElementById('message').innerText = "";
        document.getElementById('modal-overlay').classList.remove('show');
        
        renderBoard();
        renderKeyboard();
    }

    function renderBoard() {
        const board = document.getElementById('board');
        board.innerHTML = '';

        // Render past guesses
        guesses.forEach((guess, guessIndex) => {
            const row = document.createElement('div');
            row.className = 'row';
            
            const targetArr = cleanTarget.split('');
            const guessArr = guess.split('');
            
            // First pass: Correct (Green)
            const status = new Array(guess.length).fill('absent');
            const targetCounts = {};
            
            targetArr.forEach(char => targetCounts[char] = (targetCounts[char] || 0) + 1);

            guessArr.forEach((char, i) => {
                if (char === targetArr[i]) {
                    status[i] = 'correct';
                    targetCounts[char]--;
                }
            });

            // Second pass: Present (Yellow)
            guessArr.forEach((char, i) => {
                if (status[i] !== 'correct' && targetCounts[char] > 0) {
                    status[i] = 'present';
                    targetCounts[char]--;
                }
            });

            guessArr.forEach((char, i) => {
                const tile = document.createElement('div');
                tile.className = `tile ${status[i]}`;
                tile.innerText = char;
                row.appendChild(tile);
            });
            board.appendChild(row);
        });

        // Render current guess row
        if (!gameOver && guesses.length < maxGuesses) {
            const row = document.createElement('div');
            row.className = 'row';
            for (let i = 0; i < cleanTarget.length; i++) {
                const tile = document.createElement('div');
                tile.className = 'tile' + (currentGuess[i] ? ' filled' : '');
                tile.innerText = currentGuess[i] || '';
                row.appendChild(tile);
            }
            board.appendChild(row);
        }
        
        // Hint about length
        if(guesses.length === 0) {
            document.getElementById('message').innerText = `Adivina el campeón de ${cleanTarget.length} letras`;
        }
    }

    // Helper to update keyboard colors based on all guesses
    function updateKeyboardColors() {
        // Reset
        for(let k in keysStatus) delete keysStatus[k];
        
        // Re-calculate from scratch
        guesses.forEach(guess => {
            const targetArr = cleanTarget.split('');
            const guessArr = guess.split('');
            
            guessArr.forEach((char, i) => {
                let status = 'absent';
                if (char === targetArr[i]) status = 'correct';
                else if (targetArr.includes(char)) status = 'present';
                
                const current = keysStatus[char];
                if (status === 'correct') keysStatus[char] = 'correct';
                else if (status === 'present' && current !== 'correct') keysStatus[char] = 'present';
                else if (status === 'absent' && current !== 'correct' && current !== 'present') keysStatus[char] = 'absent';
            });
        });
        renderKeyboard();
    }

    const keysStatus = {};

    function renderKeyboard() {
        const keyboard = document.getElementById('keyboard');
        keyboard.innerHTML = '';
        const rows = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];
        
        rows.forEach(rowStr => {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'key-row';
            rowStr.split('').forEach(char => {
                const key = document.createElement('div');
                key.className = `key ${keysStatus[char] || ''}`;
                key.innerText = char;
                key.onclick = () => handleInput(char);
                rowDiv.appendChild(key);
            });
            if(rowStr === "ZXCVBNM") {
                const back = document.createElement('div');
                back.className = 'key';
                back.innerText = '⌫';
                back.onclick = () => handleInput('BACKSPACE');
                rowDiv.appendChild(back);
                
                const enter = document.createElement('div');
                enter.className = 'key';
                enter.innerText = 'ENTER';
                enter.onclick = () => handleInput('ENTER');
                rowDiv.appendChild(enter);
            }
            keyboard.appendChild(rowDiv);
        });
    }

    async function handleInput(key) {
        if (gameOver) return;

        if (key === 'BACKSPACE') {
            currentGuess.pop();
            renderBoard();
        } else if (key === 'ENTER') {
            if (currentGuess.length !== cleanTarget.length) {
                const row = document.querySelector('#board .row:last-child');
                if(row) {
                    row.classList.add('shake');
                    setTimeout(() => row.classList.remove('shake'), 500);
                }
                showMessage("¡Faltan letras!");
                return;
            }
            const guessStr = currentGuess.join('');
            
            // Animate Reveal
            const row = document.querySelector('#board .row:last-child');
            const tiles = row.querySelectorAll('.tile');
            
            // Calculate colors for this guess
            const targetArr = cleanTarget.split('');
            const guessArr = guessStr.split('');
            const status = new Array(guessStr.length).fill('absent');
            const targetCounts = {};
            targetArr.forEach(char => targetCounts[char] = (targetCounts[char] || 0) + 1);

            guessArr.forEach((char, i) => {
                if (char === targetArr[i]) {
                    status[i] = 'correct';
                    targetCounts[char]--;
                }
            });
            guessArr.forEach((char, i) => {
                if (status[i] !== 'correct' && targetCounts[char] > 0) {
                    status[i] = 'present';
                    targetCounts[char]--;
                }
            });

            // Apply animation sequentially
            for(let i=0; i<tiles.length; i++) {
                tiles[i].style.animationDelay = `${i * 0.1}s`;
                tiles[i].classList.add('flip');
                // Wait for half flip to change color
                setTimeout(() => {
                    tiles[i].classList.add(status[i]);
                }, (i * 100) + 250);
            }

            // Wait for all animations to finish before proceeding
            await new Promise(r => setTimeout(r, (tiles.length * 100) + 600));

            guesses.push(guessStr);
            currentGuess = [];
            updateKeyboardColors();
            
            if (guessStr === cleanTarget) {
                endGame(true);
            } else if (guesses.length >= maxGuesses) {
                endGame(false);
            } else {
                renderBoard(); // Prepare next row
            }
        } else if (currentGuess.length < cleanTarget.length && /^[A-Z]$/.test(key)) {
            currentGuess.push(key);
            renderBoard();
        }
    }

    document.addEventListener('keydown', (e) => {
        const key = e.key.toUpperCase();
        if (key === 'ENTER' || key === 'BACKSPACE' || /^[A-Z]$/.test(key)) {
            handleInput(key);
        }
    });
    
    function showMessage(msg) {
        const m = document.getElementById('message');
        m.innerText = msg;
        setTimeout(() => m.innerText = "", 2000);
    }

    function endGame(win) {
        gameOver = true;
        const modal = document.getElementById('modal-overlay');
        const title = document.getElementById('modal-title');
        const content = document.getElementById('modal-content');
        
        title.innerText = win ? "¡VICTORIA!" : "DERROTA";
        title.style.color = win ? "var(--correct)" : "#f87171";
        
        const exceptions = {
            "Wukong": "MonkeyKing", "Renata Glasc": "Renata", "Nunu & Willump": "Nunu",
            "LeBlanc": "Leblanc", "Kha'Zix": "Khazix", "Cho'Gath": "Chogath",
            "Kai'Sa": "Kaisa", "Vel'Koz": "Velkoz", "Bel'Veth": "Belveth"
        };
        let splashName = targetName.replace(/[^a-zA-Z]/g, '');
        if (exceptions[targetName]) splashName = exceptions[targetName];
        
        content.innerHTML = `
            <p>El campeón era <strong>${targetName}</strong></p>
            <img src="https://ddragon.leagueoflegends.com/cdn/img/champion/splash/${splashName}_0.jpg" class="modal-img" onerror="this.src='https://ddragon.leagueoflegends.com/cdn/img/champion/splash/${targetName}_0.jpg'">
            <p>${win ? "¡Has demostrado tu conocimiento de la Grieta!" : "¡Suerte para la próxima!"}</p>
        `;
        
        modal.classList.add('show');
        if(win) confettiEffect();
    }
    
    function confettiEffect() {
        // Simple visual effect
        // document.body.style.background = "linear-gradient(45deg, #064e3b, #020617)";
    }

    loadChampions();
</script>
</body>
</html>
